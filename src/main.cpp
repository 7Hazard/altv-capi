/**
 * This clang tool is primarily made to process alt:V's cpp-sdk for CAPI
 */

#include "tool.hpp"

#include <clang/Frontend/CompilerInstance.h>
#include <clang/Frontend/ASTUnit.h>
#include <clang/Frontend/Utils.h>

constexpr const char* headerstart = R"(
/**
 * THIS HEADER IS AUTOGENERATED
 * )" __DATE__ " " __TIME__ R"(
 * 
 * Include header for alt:V C API
 */

#ifndef _CAPI_H_
#define _CAPI_H_

#ifdef __cplusplus
#define _Bool bool
#define CAPIEXTERN extern "C"
#else
#include <stdbool.h>
#define CAPIEXTERN
#endif // __cplusplus

#ifdef _WIN32
#define CAPI CAPIEXTERN __declspec(dllimport)
#else
#define CAPI CAPIEXTERN
#endif // _WIN32

)";

constexpr const char* headerend = R"(
#endif // _CAPI_H_
)";

constexpr const char* sourcestart = R"(
/**
 * THIS HEADER IS AUTOGENERATED
 * )" __DATE__ " " __TIME__ R"(
 * 
 * Source implementation for alt:V C API
 */

#define ALT_SERVER_API
#include "cpp-sdk/SDK.h"

#include ")" HeaderFileName R"("
#ifdef _WIN32
#define CAPI CAPIEXTERN __declspec(dllexport)
#else
    #define CAPI CAPIEXTERN
#endif // _WIN32

using namespace alt;

)";

constexpr const char* sourceend = R"(

)";

LangOptions lo;
PrintingPolicy pp(lo);

// AST
std::error_code ec;
raw_fd_ostream ast(ASTFileName, ec);

// Log
std::ofstream logfile(LogFileName);

// JSON
json capijson = json::object();

// Header/Source outputs
std::ofstream capiheader(HeaderFileName);
std::ofstream capisource(SourceFileName);

// 
std::unordered_set<std::string> typedefs;

/**
 * Fix some errors in the compiler invocation before sending it to clang.
 *
 * This is a hack! Some header search path by default is incorrect. It causes
 * libclang not able to find stddef.h. This method is only tested on Arch Linux.
 */
// void fix_invocation(CompilerInvocation& invoc) {
//     for (auto& entry : invoc.getHeaderSearchOpts().UserEntries) {
//         if (entry.IsInternal) {
//             if (!boost::filesystem::is_directory(entry.Path)) {
//                 entry.Path = "/usr/bin/" + entry.Path;
//             }
//         }
//     }
// }

/**
 * Get the AST unit from the files provided in the command line.
 */
std::unique_ptr<ASTUnit> get_ast_unit(int argc, const char **argv) {
    DiagnosticOptions diag_opts;
    diag_opts.ShowColors = true;

    auto diags = CompilerInstance::createDiagnostics(&diag_opts);

    std::vector<const char*> command_args_vector{
        "-std=c++17",
        "-x", "c++"
    };
    std::copy_n(argv + 1, argc - 1, std::back_inserter(command_args_vector));

    auto command_args = llvm::makeArrayRef(command_args_vector);
    auto invoc = clang::createInvocationFromCommandLine(command_args, diags);

    if (invoc == nullptr) {
        return nullptr;
    }

    //fix_invocation(*invoc);
    
    //PCHContainerOperations pchops;
    auto filemgr = new FileManager(invoc->getFileSystemOpts());
    auto gg = std::shared_ptr<PCHContainerOperations>(new PCHContainerOperations());
    auto gg2 = std::shared_ptr<CompilerInvocation>(invoc.release());
    auto raw_unit = ASTUnit::LoadFromCompilerInvocation(
        gg2,
        gg,
        diags,
        filemgr
    );
    return raw_unit;
}

std::unique_ptr<ASTUnit> unit;
Sema* semma;

int main(int argc, const char **argv)
{
    pp.SuppressTagKeyword = true;
    pp.FullyQualifiedName = true;

    cl::OptionCategory category("apt-tool options");
    CommonOptionsParser optionsParser(argc, argv, category, 0);

    // Get Sema
    unit = get_ast_unit(argc, argv);
    semma = &unit->getSema();

    std::cout << "Generating CAPI..." << std::endl;

    // Header/Source start
    capiheader << headerstart;
    capisource << sourcestart;

    // Run handlers
    ClangTool tool(optionsParser.getCompilations(),
                    optionsParser.getSourcePathList());
    Handler::ExecuteAll(tool);
    
    // Header/Source end
    capiheader << headerend;
    capisource << sourceend;

    capiheader.close();
    std::cout << "Output " HeaderFileName << std::endl;

    ast.close();
    std::cout << "Output " ASTFileName << std::endl;

    std::ofstream out(JsonFileName);
    out << std::setw(4) << capijson;
    out.close();
    std::cout << "Output " JsonFileName << std::endl;

    logfile.close();
    std::cout << "Output " LogFileName << std::endl;

    return 0;
}
