/*auto GetRecordBases = [](const CXXRecordDecl *r){
    json j = json::array();
    for(auto b : r->bases())
    {
        j.push_back({
            {"kind", "base"},
            {"isVirtual", b.isVirtual()},
            {"access", GetAccessStr(b.getAccessSpecifier())},
            {"qualName", b.getType().getAsString()},
            {"name", b.getType().getNonReferenceType().getUnqualifiedType().getAsString(pp)},
        });
    }
    return j;
};

const CXXRecordDecl *rd = Result.Nodes.getNodeAs<clang::CXXRecordDecl>("records");

// Only handle local records
if (!IsRecordLocal(rd) || !rd->isThisDeclarationADefinition()) return;

// remove?
rd->dump(ast);
astOut << ast.str();
// remove?

// Set the JSON info
json recordjson = {
    {"name", rd->getQualifiedNameAsString()},
    {"baseName", rd->getNameAsString()},
    //{"qualName",  rd->getTypeForDecl() .getTypeForDecl().getAsString()},

    //{"vbases", GetRecordVBases(rd)},
    {"methods", GetRecordMethods(rd)},
    {"decls", GetRecordDecls(rd)},
    {"fields", GetRecordFields(rd)},
    //{"parent", rd->getParent()}

    {"isCLike", rd->isCLike()},
    {"kind", rd->getKindName().str()},
    {"isEnum", rd->isEnum()},
    {"isStruct", rd->isStruct()},
    {"isClass", rd->isClass()},
    {"isUnion", rd->isUnion()},

    {"isPolymorphic", rd->isPolymorphic()},
    {"bases", GetRecordBases(rd)},

    {"isTemplated", rd->isTemplated() || rd->isTemplateDecl() || rd->isTemplateParameter() || rd->isTemplateParameterPack()},
    {"templateSpecializationKind", rd->getTemplateSpecializationKind()},
    //{"describedTemplate", rd->getDescribedTemplate()->getNameAsString()},
    //{"describedClassTemplate", rd->getDescribedClassTemplate()->getNameAsString()},
    //{"getTemplateInstantiationPattern", rd->getTemplateInstantiationPattern()->getNameAsString()},

    {"isSingleton", isSingleton},
    {"containsTemplates", containsTemplates},

    {"location", rd->getLocation().printToString(rd->getASTContext().getSourceManager())},
};

// Do not output templates
containsTemplates = containsTemplates || rd->isTemplated() || rd->isTemplateDecl() || rd->isTemplateParameter() || rd->isTemplateParameterPack() || rd->getTemplateSpecializationKind() == 53;
if(containsTemplates) return;

classes.push_back(recordjson);*/


//json GetFunctionPtrInfo(QualType type) {
//    bool isFuncPtr = false;
//    if (false) {
//    }
//    return {{"isFuncPtr", false}};
//}

json GetTypeInfo(QualType type) {
    return {
        {"kind", "type"},
        {"name", type.getAsString(pp)},
        {"baseName", type.getNonReferenceType().getUnqualifiedType().getAsString(pp)},
        //{"qualifiers", type.getQualifiers().getAsString()},

        {"isFundemental", type->isFundamentalType()},
        {"isElaborated", type->isElaboratedTypeSpecifier()},
        //{"isConst", type.isConstQualified()}, // idk why it doesnt work

        // Pointer stuff
        {"isPtr", type->isPointerType()},
        {"isRef", type->isReferenceType()},
        {"pointeeType", type->isPointerType() || type->isReferenceType() ? type->getPointeeType().getAsString() : ""},
        //{"funcPtrInfo", GetFunctionPtrInfo(type)},
        //{"isFuncPtr", type->isFunctionPointerType()},
        //{"isFunctionProtoType", type->isFunctionProtoType()},
        //{"isFunc", type->isFunctionType()},
        //{"isFunctionNoProtoType", type->isFunctionNoProtoType()},

        // Template stuff
        {"isTemplated", type->isTemplateTypeParmType()},
        //{"templateArgs", type->getAs},
        
        {"isEnum", type->isEnumeralType()},
        {"isStruct", type->isStructureType()},
        {"isClass", type->isClassType()},
        {"isUnion", type->isUnionType()},

        {"typeClass", type->getTypeClassName()},
        //{"inSTD", type->getAsTagDecl()->isInStdNamespace()}
        //{"isFunc", type->isFunctionPointerType()},
        //{"funcParams", GetFuncParams(type->getAsTagDecl()->getAsFunction())},
    };
}

//json GetSubRecords(const CXXRecordDecl *record) {
//  json subRecords = json::array();
//
//  return subRecords;
//}

json GetFuncParams(FunctionDecl *func) {
    json params = json::array();
    for (auto param : func->parameters()) {
        params.push_back({
            {"type", GetTypeInfo(param->getOriginalType())},
            {"name", param->getNameAsString()},
            //{"isFunc", param->isFunctionOrFunctionTemplate()},
            //{"funcInfo", GetFuncInfo(param->getAsFunction())},
        });
    }
    return params;
}

bool containsTemplates = false;
json GetFuncInfo(NamedDecl *decl) {
    auto func = decl->getAsFunction();
    containsTemplates = containsTemplates
        || func->isTemplated() 
        || func->isTemplateDecl() 
        || func->isTemplateInstantiation() 
        || func->isTemplateParameter() 
        || func->isTemplateParameterPack();

    return {
        {"name", func->getNameAsString()},
        {"returns", GetTypeInfo(func->getReturnType())},
        {"params", GetFuncParams(func)},
        {"isOverloadedOperator", func->isOverloadedOperator()},
        {"isTemplated", containsTemplates}
    };
}

bool isSingleton = false;
json GetRecordMethods(const CXXRecordDecl *record) {
    isSingleton = false;
    containsTemplates = false;

    // Iterate over record's methods
    json methods = json::array();
    for (auto method : record->methods()) {
        // Public methods, no ctors and dtors
        if (method->getVisibility() != clang::Visibility::DefaultVisibility
            //|| method->getKind() == Decl::CXXConstructor
            //|| method->getKind() == Decl::CXXDestructor
            )
            continue;

        // Set method info from record
        methods.push_back(
            merge(GetFuncInfo(method),
                {
                    {"isCtor", method->getKind() == Decl::CXXConstructor},
                    {"isDtor", method->getKind() == Decl::CXXDestructor},
                    {"isStatic", method->isStatic()},
                    {"isVirtual", method->isVirtual()},
                    {"access", GetAccessStr(method->getAccess())},
                    {"visibility", GetVisibilityStr(method->getVisibility())},
                    {"kind", "function"},
                    {"funcKind", method->getKind()}
                }));

        if (method->isStatic() && method->getNameAsString() == "Instance")
            isSingleton = true;
    }

    return methods;
}

json GetEnumValues(EnumDecl* enumDecl)
{
    json values = json::array();
    for(auto decl : enumDecl->decls())
    {
        if(decl->getKind() != Decl::EnumConstant) continue;

        auto ec = static_cast<EnumConstantDecl*>(decl);
        values.push_back({
            {"name", ec->getNameAsString()},
            {"value", ec->getInitVal().getExtValue()},
        });
    }

    return values;
}

json GetRecordDecls(const CXXRecordDecl *record)
{
    json decls = json::array();
    for(auto decl : record->decls())
    {
        switch (decl->getKind())
        {
            case Decl::Enum:
            {
                auto ed = static_cast<EnumDecl*>(decl);
                decls.push_back({
                    {"kind", "enum"},
                    {"baseName", ed->getNameAsString()},
                    {"name", ed->getQualifiedNameAsString()},
                    {"values", GetEnumValues(ed)},
                    {"integerType", ed->getIntegerType().getAsString()}
                });
                break;
            }
        }
    }

    return decls;
}

json GetRecordFields(const CXXRecordDecl *record)
{
    json fields = json::array();
    for(auto field : record->fields())
    {
        fields.push_back({
            {"name", field->getNameAsString()},
            {"access", GetAccessStr(field->getAccess())},
            {"type", GetTypeInfo(field->getType())},
        });
    }
    
    return fields;
}
